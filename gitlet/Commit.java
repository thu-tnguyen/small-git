package gitlet;

import java.io.File;
import java.io.Serializable;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

import static gitlet.Utils.*;
import static gitlet.MainUtils.*;

/** Combinations of log messages, other metadata (commit date, author,
 *  etc.), and references to parent commits. The repository also
 *  maintains a mapping from branch heads (in this course, we've
 *  used names like master, proj2, etc.) to references to commits,
 *  so that certain important commits have symbolic names.
 *  Trees are incorporated into commit.
 *  @author Thu Nguyen
 **/
public class Commit implements Serializable {
    /** DateFormat. */
    static final DateFormat DF = new SimpleDateFormat(
            "EEE MMM d HH:mm:ss yyyy Z");
    /** Array of Blob ID's. */
    private String[] _blobIdArray;
    /** List of ID of parents of the commit (There can only be 2 parents
     *  in Gitlet). This will be used for merges. */
    private String[] _parentsID;
    /** Log message of the commit that I supply. */
    private String _logMessage;
    /** Timestamp of the commit. */
    private String _timestamp;
    /** Unique ID generated by SHA-1. Differentiated from other object
     *  types by their 5-character beginning "comm_" (for commit). */
    private String _id;

    /** Construct a default commit with no files and has message
     *  "initial commit". */
    public Commit() {
        _blobIdArray = new String[0];
        _parentsID = new String[2];
        _parentsID[0] = _parentsID[1] = null;
        _logMessage = "initial commit";
        _timestamp = DF.format(new Date(0));
        byte[] serialized = serialize(this);
        _id = "comm_" + sha1(serialized);
        writeContents(join(OBJECTS_DIR.toString(), _id), serialized);
    }

    /** Construct a commit with files from add staging area, and has
     *  message LOGMESSAGE. Parent IS PARENTID. Time set to current
     *  time. BLOBIDS HAS FORM: [FILENAME]+[UID].txt. */
    public Commit(String logMessage, String[] blobIDs, String parentID) {
        _parentsID = new String[2];
        _parentsID[0] = parentID;
        _parentsID[1] = null;
        _blobIdArray = blobIDs;
        _logMessage = logMessage;
        _timestamp = DF.format(new Date());
        byte[] serialized = serialize(this);
        _id = "comm_" + sha1(serialized);
        writeContents(join(OBJECTS_DIR.toString(), _id), serialized);
    }

    /** Construct a commit with files from add staging area, and has
     *  message LOGMESSAGE. Parents are PARENTID1 and PARENTID2. Time
     *  set to current time. BLOBIDS HAS FORM: [FILENAME]+[UID]. */
    public Commit(String logMessage, String[] blobIDs, String parentID1,
                  String parentID2) {
        _parentsID = new String[2];
        _parentsID[0] = parentID1;
        _parentsID[1] = parentID2;
        _blobIdArray = blobIDs;
        _logMessage = logMessage;
        _timestamp = DF.format(new Date());
        byte[] serialized = serialize(this);
        _id = "comm_" + sha1(serialized);
        writeContents(join(OBJECTS_DIR.toString(), _id), serialized);
    }

    /** Return my id. */
    public String getID() {
        return this._id;
    }

    /** Return my array of blob ID's. */
    public String[] getBlobIDArray() {
        return this._blobIdArray;
    }

    /** Return my array of parents' ID. */
    public String[] getParentsID() {
        return this._parentsID;
    }

    /** Return my log message. */
    public String getLogMessage() {
        return this._logMessage;
    }
    /** Return my time stamp. */
    public String getTimeStamp() {
        return this._timestamp;
    }

    /** Return commit from its TRUNCATEDID. Return null
     *  if commit does not exist. */
    static Commit getCommit(String truncatedId) {
        if (Files.exists(Paths.get(OBJECTS_DIR.toString(), "comm_"
                + truncatedId))) {
            return readObject(join(OBJECTS_DIR.toString(), "comm_"
                    + truncatedId), Commit.class);
        }
        return null;
    }

    /** Recover and return the UID (ID without "comm_" beginning) from
     * SHORTENEDID. Return empty string if commit does not exist. */
    static String recoverUID(String shortenedID) {
        String substringID = "comm_" + shortenedID;
        for (File file : OBJECTS_DIR.toFile().listFiles()) {
            String fileName = file.getName();
            if (isCommitId(fileName) && fileName.contains(substringID)) {
                return fileName.substring(5);
            }
        }
        return "";
    }

    /** Return whether the ID is a commit's ID.
     *  Check if the first 5 characters are "comm_" and that the the total
     *  length equals to length of "comm_" + UID_LENGTH, which has length
     *  5 + UID_LENGTH. */
    static boolean isCommitId(String id) {
        return id.substring(0, 5).compareTo("comm_") == 0
                && id.length() == 5 + UID_LENGTH;
    }

    /** Return true if COMM1 and COMM2 are the same commit (having same
     * variables). */
    static boolean sameCommit(Commit comm1, Commit comm2) {
        if (comm1 != null && comm2 != null) {
            if (Arrays.equals(comm1._parentsID, comm2._parentsID)
                    && Arrays.equals(comm1._blobIdArray, comm2._blobIdArray)
                    && comm1._logMessage.compareTo(comm2._logMessage) == 0
                    && comm1._timestamp.compareTo(comm2._timestamp) == 0) {
                return true;
            }
        }
        return false;
    }
}
